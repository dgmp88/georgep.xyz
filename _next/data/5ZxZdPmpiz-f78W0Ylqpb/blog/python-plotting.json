{"pageProps":{"meta":{"title":"Python Plotting Libraries","date":"2019/01/20"},"content":"<p>TLDR: Use matplotlib for speed if you're just doing a quick analysis for yourself. If you're sharing the plots, plotly is definitely worth checking out.</p>\n<p>I've used <a href=\"https://matplotlib.org/\">matplotlib</a> for a while and it's awesome - simple API, lots of plotting options. The defaults can be a little ugly, but <a href=\"https://seaborn.pydata.org/\">seaborn</a> can very easily make them all much nicer. However, the graphs generated are pngs/svgs, so don't scale that easily and miss out on some cool interactive features of other libraries.</p>\n<p><a href=\"https://bokeh.pydata.org/en/latest/\">Bokeh</a> and <a href=\"https://plot.ly/\">Plotly</a> are two good alternatives. Both are open source, though plotly has a for profit branch linked to Dash, a framework for building analytical webapps. You don't need to use it, but default/examples on their docs often do.</p>\n<p>Here I want to compare the 3 on ease of use, functionality and aesthetics.</p>\n<h2 id=\"installation\">Installation</h2>\n<p>Plotly and Matplotlib are very easy with pip or conda (<code>conda install plotly/matplotlib</code>). Bokeh also works via pip or seaborn, but if you want it to work with JupyterLab, you'll need an extension: <code>jupyter labextension install jupyterlab_bokeh</code>.</p>\n<h2 id=\"basicexampleslineplot\">Basic examples: Line Plot</h2>\n<p>These are deliberately very bare bones and are just examples of plots I do most frequently. All of the frameworks are super customisable, but if you're running a quick analysis you often just want the core features, so I'm not generally bothering with axis labels and legends.</p>\n<h3 id=\"data\">Data</h3>\n<p>Generate some nice offset sine waves and a legend.</p>\n<pre><code class=\"python language-python\">import numpy as np\n\n# Linearly spaced, 0 - 2 * pi\nx = np.linspace(0, np.pi*2, 1000)\n\ndata = [('offset %1.2f' % i, np.sin(x+i)) for i in np.linspace(0, np.pi, 10)]\nlegend, ys = zip(*data)\n</code></pre>\n<h3 id=\"matplotlib\">Matplotlib</h3>\n<pre><code class=\"python language-python\">%matplotlib inline\n# The first line above needs to be called once to make outputs appear inline in jupyter\n\nimport matplotlib.pyplot as plt\n\n# I lied: this is a litte formatting to make the default size comparable to the others.\nplt.figure(figsize=(10, 7))\n\n\nfor y in ys:\n    plt.plot(x, y)\n_ = plt.legend(legend)\n</code></pre>\n<p><img src=\"/images/plotting/matplotlib_line.png\" alt=\"Matplotlib\" /></p>\n<h3 id=\"plotly\">Plotly</h3>\n<p>A little bit more boilerplate. We need to generate a bunch of 'traces', which are basically just dictionaries, and then hand them to the plotting function.</p>\n<pre><code class=\"python language-python\">import plotly.graph_objs as go\nimport plotly.offline as py\n\ntraces = []\n\nfor leg, y in zip(legend, ys):\n    traces.append(go.Scatter(x=x, y=y, name=leg))\n\npy.iplot(traces)\n</code></pre>\n<iframe\n  width=\"100%\"\n  height=\"500px\"\n  src=\"/iframes/plotly_line.html\"\n  frameborder=\"0\"\n></iframe>\n<h3 id=\"bokeh\">Bokeh</h3>\n<p>Note that we have to set <code>output_notebook</code> to plot inside the notebook. The alternative is <code>output_file('filename.html')</code>.</p>\n<pre><code class=\"python language-python\">from bokeh.plotting import figure, output_notebook, show\n\noutput_notebook()\n\np = figure()\n\nfor leg, y in zip(legend, ys):\n    p.line(x, y, legend=leg)\n\nshow(p)\n</code></pre>\n<iframe\n  width=\"100%\"\n  height=\"650px\"\n  src=\"/iframes/bokeh_line.html\"\n  frameborder=\"0\"\n></iframe>\n<h3 id=\"interimconclusion\">Interim conclusion</h3>\n<p>I love the conciseness of the matplotlib API, the others feel clunky to me in comparsion. But maybe that's just what I'm used to. The interactivity and aesthetics of the others are definitely better though.</p>\n<h2 id=\"basicexampleshistogram\">Basic examples: histogram</h2>\n<p>I made scatter plots, they work similarly to the line plots and aren't that interesting to show. Perhaps a more interesting example is something more complex that I also use quite a lot - a histogram of the data to get an idea of its distribution.</p>\n<p>The data, random and normally distributed.</p>\n<pre><code class=\"python language-python\">x = np.random.normal(size=10000)\n</code></pre>\n<h3 id=\"matplotlib-1\">Matplotlib</h3>\n<p>It doesn't get much more concise than this.</p>\n<pre><code class=\"python language-python\">plt.hist(x)\n</code></pre>\n<p><img src=\"/images/plotting/matplotlib_hist.png\" alt=\"Matplotlib\" /></p>\n<h3 id=\"plotly-1\">Plotly</h3>\n<p>Also pretty terse.</p>\n<pre><code class=\"python language-python\">traces = [go.Histogram(x=x)]\n\npy.plot(traces)\n</code></pre>\n<iframe\n  width=\"100%\"\n  height=\"500px\"\n  src=\"/iframes/plotly_hist.html\"\n  frameborder=\"0\"\n></iframe>\n<h3 id=\"bokeh-1\">Bokeh</h3>\n<p>By far the most complex as this isn't built in, so we're basically just making a bar plot (not sure why this is called 'quad' here). This is adapted from their docs <a href=\"https://bokeh.pydata.org/en/latest/docs/gallery/histogram.html\">here</a>.</p>\n<pre><code class=\"python language-python\"># Get the bins for the histogram\nhist, edges = np.histogram(x, density=True, bins=100)\nxx = np.linspace(-2, 2, 1000)\n\np = figure()\np.quad(top=hist, bottom=0, left=edges[:-1], right=edges[1:])\nshow(p)\n</code></pre>\n<iframe\n  width=\"100%\"\n  height=\"650px\"\n  src=\"/iframes/bokeh_hist.html\"\n  frameborder=\"0\"\n></iframe>\n<h2 id=\"misc\">Misc</h2>\n<ul>\n<li>Something kept crashing my jupyter notebook page after some time had gone by since plotting. It looks like the culprit was Bokeh, but it was a little hard to reproduce.</li>\n<li>Both Bokeh and Plotly get a fair bit slower if you have loads of data. e.g. measuring time to render with a stopwatch (<code>%timeit</code> magic wont measure frontend stuff) and changing the line plot to show 100 examples took:</li>\n<li>2.6s with matplotlib</li>\n<li>9.2s with plotly</li>\n<li>7.8s with bokeh.</li>\n</ul>\n<h2 id=\"winners\">Winners</h2>\n<h3 id=\"easeofusematplotlib\">Ease of use: matplotlib</h3>\n<p>For basic things mpl had the least lines of code and was most intuitive off the bat. Plotly would follow as it has more tools included.</p>\n<h3 id=\"interactivitybokeh\">Interactivity: bokeh</h3>\n<p>Both are nice, if a little slow sometimes. This was worse in jupyter than on this site. I slightly prefer the lack of hover info by default in bokeh, and also click to drag just feels more natural as the default setting. Not much in it though. Apparently it is possible to get interactive plots inside jupyter with matplotlib, but I've found it a hassle to setup and slightly unreliable.</p>\n<h3 id=\"aestheticsplotly\">Aesthetics: plotly</h3>\n<p>Lovely looking plots as default. Personal preference, but a clear winner for me.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>For client-facing tasks, I'll use plotly in the future. For generating quick plots to examine data for my own sake, I'll stick with matplotlib as it's much faster, both in terms of time to render and in terms of using the API. I sometimes use matplotlib with seaborn to make it prettier to show people internally if I'm feeling fancy.</p>\n<p>It's a little rough, but you can see the Jupyter Notebook I based this on <a href=\"https://github.com/dgmp88/dgmp88.github.io/tree/master/notebooks/Plotting.ipynb\">here</a>.</p>"},"__N_SSG":true}