<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/9ca906896d42707f.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9ca906896d42707f.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-c49f20c74839094f.js" defer=""></script><script src="/_next/static/chunks/framework-fc97f3f1282ce3ed.js" defer=""></script><script src="/_next/static/chunks/main-f4ae3437c92c1efc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-d486b909caea9e66.js" defer=""></script><script src="/_next/static/chunks/586-fc70be302fad1b1f.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-945720dc868c05e4.js" defer=""></script><script src="/_next/static/KH68ggqkYmcXHfjfz910M/_buildManifest.js" defer=""></script><script src="/_next/static/KH68ggqkYmcXHfjfz910M/_ssgManifest.js" defer=""></script><script src="/_next/static/KH68ggqkYmcXHfjfz910M/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div class="navbar"><div class="flex-1"><a class="btn btn-ghost normal-case text-xl" href="/">George Prichard</a></div><div class="flex-none"><ul class="menu menu-horizontal p-0"><li><a href="/blog">Blog</a></li></ul></div></div><div class="prose lg:prose-lg mx-auto px-4 py-8"><h1>Python Plotting Libraries</h1><div><p>TLDR: Use matplotlib for speed if you're just doing a quick analysis for yourself. If you're sharing the plots, plotly is definitely worth checking out.</p>
<p>I've used <a href="https://matplotlib.org/">matplotlib</a> for a while and it's awesome - simple API, lots of plotting options. The defaults can be a little ugly, but <a href="https://seaborn.pydata.org/">seaborn</a> can very easily make them all much nicer. However, the graphs generated are pngs/svgs, so don't scale that easily and miss out on some cool interactive features of other libraries.</p>
<p><a href="https://bokeh.pydata.org/en/latest/">Bokeh</a> and <a href="https://plot.ly/">Plotly</a> are two good alternatives. Both are open source, though plotly has a for profit branch linked to Dash, a framework for building analytical webapps. You don't need to use it, but default/examples on their docs often do.</p>
<p>Here I want to compare the 3 on ease of use, functionality and aesthetics.</p>
<h2 id="installation">Installation</h2>
<p>Plotly and Matplotlib are very easy with pip or conda (<code>conda install plotly/matplotlib</code>). Bokeh also works via pip or seaborn, but if you want it to work with JupyterLab, you'll need an extension: <code>jupyter labextension install jupyterlab_bokeh</code>.</p>
<h2 id="basicexampleslineplot">Basic examples: Line Plot</h2>
<p>These are deliberately very bare bones and are just examples of plots I do most frequently. All of the frameworks are super customisable, but if you're running a quick analysis you often just want the core features, so I'm not generally bothering with axis labels and legends.</p>
<h3 id="data">Data</h3>
<p>Generate some nice offset sine waves and a legend.</p>
<pre><code class="python language-python">import numpy as np

# Linearly spaced, 0 - 2 * pi
x = np.linspace(0, np.pi*2, 1000)

data = [('offset %1.2f' % i, np.sin(x+i)) for i in np.linspace(0, np.pi, 10)]
legend, ys = zip(*data)
</code></pre>
<h3 id="matplotlib">Matplotlib</h3>
<pre><code class="python language-python">%matplotlib inline
# The first line above needs to be called once to make outputs appear inline in jupyter

import matplotlib.pyplot as plt

# I lied: this is a litte formatting to make the default size comparable to the others.
plt.figure(figsize=(10, 7))


for y in ys:
    plt.plot(x, y)
_ = plt.legend(legend)
</code></pre>
<p><img src="/images/plotting/matplotlib_line.png" alt="Matplotlib" /></p>
<h3 id="plotly">Plotly</h3>
<p>A little bit more boilerplate. We need to generate a bunch of 'traces', which are basically just dictionaries, and then hand them to the plotting function.</p>
<pre><code class="python language-python">import plotly.graph_objs as go
import plotly.offline as py

traces = []

for leg, y in zip(legend, ys):
    traces.append(go.Scatter(x=x, y=y, name=leg))

py.iplot(traces)
</code></pre>
<iframe
  width="100%"
  height="500px"
  src="/iframes/plotly_line.html"
  frameborder="0"
></iframe>
<h3 id="bokeh">Bokeh</h3>
<p>Note that we have to set <code>output_notebook</code> to plot inside the notebook. The alternative is <code>output_file('filename.html')</code>.</p>
<pre><code class="python language-python">from bokeh.plotting import figure, output_notebook, show

output_notebook()

p = figure()

for leg, y in zip(legend, ys):
    p.line(x, y, legend=leg)

show(p)
</code></pre>
<iframe
  width="100%"
  height="650px"
  src="/iframes/bokeh_line.html"
  frameborder="0"
></iframe>
<h3 id="interimconclusion">Interim conclusion</h3>
<p>I love the conciseness of the matplotlib API, the others feel clunky to me in comparsion. But maybe that's just what I'm used to. The interactivity and aesthetics of the others are definitely better though.</p>
<h2 id="basicexampleshistogram">Basic examples: histogram</h2>
<p>I made scatter plots, they work similarly to the line plots and aren't that interesting to show. Perhaps a more interesting example is something more complex that I also use quite a lot - a histogram of the data to get an idea of its distribution.</p>
<p>The data, random and normally distributed.</p>
<pre><code class="python language-python">x = np.random.normal(size=10000)
</code></pre>
<h3 id="matplotlib-1">Matplotlib</h3>
<p>It doesn't get much more concise than this.</p>
<pre><code class="python language-python">plt.hist(x)
</code></pre>
<p><img src="/images/plotting/matplotlib_hist.png" alt="Matplotlib" /></p>
<h3 id="plotly-1">Plotly</h3>
<p>Also pretty terse.</p>
<pre><code class="python language-python">traces = [go.Histogram(x=x)]

py.plot(traces)
</code></pre>
<iframe
  width="100%"
  height="500px"
  src="/iframes/plotly_hist.html"
  frameborder="0"
></iframe>
<h3 id="bokeh-1">Bokeh</h3>
<p>By far the most complex as this isn't built in, so we're basically just making a bar plot (not sure why this is called 'quad' here). This is adapted from their docs <a href="https://bokeh.pydata.org/en/latest/docs/gallery/histogram.html">here</a>.</p>
<pre><code class="python language-python"># Get the bins for the histogram
hist, edges = np.histogram(x, density=True, bins=100)
xx = np.linspace(-2, 2, 1000)

p = figure()
p.quad(top=hist, bottom=0, left=edges[:-1], right=edges[1:])
show(p)
</code></pre>
<iframe
  width="100%"
  height="650px"
  src="/iframes/bokeh_hist.html"
  frameborder="0"
></iframe>
<h2 id="misc">Misc</h2>
<ul>
<li>Something kept crashing my jupyter notebook page after some time had gone by since plotting. It looks like the culprit was Bokeh, but it was a little hard to reproduce.</li>
<li>Both Bokeh and Plotly get a fair bit slower if you have loads of data. e.g. measuring time to render with a stopwatch (<code>%timeit</code> magic wont measure frontend stuff) and changing the line plot to show 100 examples took:</li>
<li>2.6s with matplotlib</li>
<li>9.2s with plotly</li>
<li>7.8s with bokeh.</li>
</ul>
<h2 id="winners">Winners</h2>
<h3 id="easeofusematplotlib">Ease of use: matplotlib</h3>
<p>For basic things mpl had the least lines of code and was most intuitive off the bat. Plotly would follow as it has more tools included.</p>
<h3 id="interactivitybokeh">Interactivity: bokeh</h3>
<p>Both are nice, if a little slow sometimes. This was worse in jupyter than on this site. I slightly prefer the lack of hover info by default in bokeh, and also click to drag just feels more natural as the default setting. Not much in it though. Apparently it is possible to get interactive plots inside jupyter with matplotlib, but I've found it a hassle to setup and slightly unreliable.</p>
<h3 id="aestheticsplotly">Aesthetics: plotly</h3>
<p>Lovely looking plots as default. Personal preference, but a clear winner for me.</p>
<h2 id="conclusion">Conclusion</h2>
<p>For client-facing tasks, I'll use plotly in the future. For generating quick plots to examine data for my own sake, I'll stick with matplotlib as it's much faster, both in terms of time to render and in terms of using the API. I sometimes use matplotlib with seaborn to make it prettier to show people internally if I'm feeling fancy.</p>
<p>It's a little rough, but you can see the Jupyter Notebook I based this on <a href="https://github.com/dgmp88/dgmp88.github.io/tree/master/notebooks/Plotting.ipynb">here</a>.</p></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"meta":{"title":"Python Plotting Libraries","date":"2019/01/20"},"content":"\u003cp\u003eTLDR: Use matplotlib for speed if you're just doing a quick analysis for yourself. If you're sharing the plots, plotly is definitely worth checking out.\u003c/p\u003e\n\u003cp\u003eI've used \u003ca href=\"https://matplotlib.org/\"\u003ematplotlib\u003c/a\u003e for a while and it's awesome - simple API, lots of plotting options. The defaults can be a little ugly, but \u003ca href=\"https://seaborn.pydata.org/\"\u003eseaborn\u003c/a\u003e can very easily make them all much nicer. However, the graphs generated are pngs/svgs, so don't scale that easily and miss out on some cool interactive features of other libraries.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://bokeh.pydata.org/en/latest/\"\u003eBokeh\u003c/a\u003e and \u003ca href=\"https://plot.ly/\"\u003ePlotly\u003c/a\u003e are two good alternatives. Both are open source, though plotly has a for profit branch linked to Dash, a framework for building analytical webapps. You don't need to use it, but default/examples on their docs often do.\u003c/p\u003e\n\u003cp\u003eHere I want to compare the 3 on ease of use, functionality and aesthetics.\u003c/p\u003e\n\u003ch2 id=\"installation\"\u003eInstallation\u003c/h2\u003e\n\u003cp\u003ePlotly and Matplotlib are very easy with pip or conda (\u003ccode\u003econda install plotly/matplotlib\u003c/code\u003e). Bokeh also works via pip or seaborn, but if you want it to work with JupyterLab, you'll need an extension: \u003ccode\u003ejupyter labextension install jupyterlab_bokeh\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"basicexampleslineplot\"\u003eBasic examples: Line Plot\u003c/h2\u003e\n\u003cp\u003eThese are deliberately very bare bones and are just examples of plots I do most frequently. All of the frameworks are super customisable, but if you're running a quick analysis you often just want the core features, so I'm not generally bothering with axis labels and legends.\u003c/p\u003e\n\u003ch3 id=\"data\"\u003eData\u003c/h3\u003e\n\u003cp\u003eGenerate some nice offset sine waves and a legend.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"python language-python\"\u003eimport numpy as np\n\n# Linearly spaced, 0 - 2 * pi\nx = np.linspace(0, np.pi*2, 1000)\n\ndata = [('offset %1.2f' % i, np.sin(x+i)) for i in np.linspace(0, np.pi, 10)]\nlegend, ys = zip(*data)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"matplotlib\"\u003eMatplotlib\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"python language-python\"\u003e%matplotlib inline\n# The first line above needs to be called once to make outputs appear inline in jupyter\n\nimport matplotlib.pyplot as plt\n\n# I lied: this is a litte formatting to make the default size comparable to the others.\nplt.figure(figsize=(10, 7))\n\n\nfor y in ys:\n    plt.plot(x, y)\n_ = plt.legend(legend)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/images/plotting/matplotlib_line.png\" alt=\"Matplotlib\" /\u003e\u003c/p\u003e\n\u003ch3 id=\"plotly\"\u003ePlotly\u003c/h3\u003e\n\u003cp\u003eA little bit more boilerplate. We need to generate a bunch of 'traces', which are basically just dictionaries, and then hand them to the plotting function.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"python language-python\"\u003eimport plotly.graph_objs as go\nimport plotly.offline as py\n\ntraces = []\n\nfor leg, y in zip(legend, ys):\n    traces.append(go.Scatter(x=x, y=y, name=leg))\n\npy.iplot(traces)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ciframe\n  width=\"100%\"\n  height=\"500px\"\n  src=\"/iframes/plotly_line.html\"\n  frameborder=\"0\"\n\u003e\u003c/iframe\u003e\n\u003ch3 id=\"bokeh\"\u003eBokeh\u003c/h3\u003e\n\u003cp\u003eNote that we have to set \u003ccode\u003eoutput_notebook\u003c/code\u003e to plot inside the notebook. The alternative is \u003ccode\u003eoutput_file('filename.html')\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"python language-python\"\u003efrom bokeh.plotting import figure, output_notebook, show\n\noutput_notebook()\n\np = figure()\n\nfor leg, y in zip(legend, ys):\n    p.line(x, y, legend=leg)\n\nshow(p)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ciframe\n  width=\"100%\"\n  height=\"650px\"\n  src=\"/iframes/bokeh_line.html\"\n  frameborder=\"0\"\n\u003e\u003c/iframe\u003e\n\u003ch3 id=\"interimconclusion\"\u003eInterim conclusion\u003c/h3\u003e\n\u003cp\u003eI love the conciseness of the matplotlib API, the others feel clunky to me in comparsion. But maybe that's just what I'm used to. The interactivity and aesthetics of the others are definitely better though.\u003c/p\u003e\n\u003ch2 id=\"basicexampleshistogram\"\u003eBasic examples: histogram\u003c/h2\u003e\n\u003cp\u003eI made scatter plots, they work similarly to the line plots and aren't that interesting to show. Perhaps a more interesting example is something more complex that I also use quite a lot - a histogram of the data to get an idea of its distribution.\u003c/p\u003e\n\u003cp\u003eThe data, random and normally distributed.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"python language-python\"\u003ex = np.random.normal(size=10000)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"matplotlib-1\"\u003eMatplotlib\u003c/h3\u003e\n\u003cp\u003eIt doesn't get much more concise than this.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"python language-python\"\u003eplt.hist(x)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/images/plotting/matplotlib_hist.png\" alt=\"Matplotlib\" /\u003e\u003c/p\u003e\n\u003ch3 id=\"plotly-1\"\u003ePlotly\u003c/h3\u003e\n\u003cp\u003eAlso pretty terse.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"python language-python\"\u003etraces = [go.Histogram(x=x)]\n\npy.plot(traces)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ciframe\n  width=\"100%\"\n  height=\"500px\"\n  src=\"/iframes/plotly_hist.html\"\n  frameborder=\"0\"\n\u003e\u003c/iframe\u003e\n\u003ch3 id=\"bokeh-1\"\u003eBokeh\u003c/h3\u003e\n\u003cp\u003eBy far the most complex as this isn't built in, so we're basically just making a bar plot (not sure why this is called 'quad' here). This is adapted from their docs \u003ca href=\"https://bokeh.pydata.org/en/latest/docs/gallery/histogram.html\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"python language-python\"\u003e# Get the bins for the histogram\nhist, edges = np.histogram(x, density=True, bins=100)\nxx = np.linspace(-2, 2, 1000)\n\np = figure()\np.quad(top=hist, bottom=0, left=edges[:-1], right=edges[1:])\nshow(p)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ciframe\n  width=\"100%\"\n  height=\"650px\"\n  src=\"/iframes/bokeh_hist.html\"\n  frameborder=\"0\"\n\u003e\u003c/iframe\u003e\n\u003ch2 id=\"misc\"\u003eMisc\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eSomething kept crashing my jupyter notebook page after some time had gone by since plotting. It looks like the culprit was Bokeh, but it was a little hard to reproduce.\u003c/li\u003e\n\u003cli\u003eBoth Bokeh and Plotly get a fair bit slower if you have loads of data. e.g. measuring time to render with a stopwatch (\u003ccode\u003e%timeit\u003c/code\u003e magic wont measure frontend stuff) and changing the line plot to show 100 examples took:\u003c/li\u003e\n\u003cli\u003e2.6s with matplotlib\u003c/li\u003e\n\u003cli\u003e9.2s with plotly\u003c/li\u003e\n\u003cli\u003e7.8s with bokeh.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"winners\"\u003eWinners\u003c/h2\u003e\n\u003ch3 id=\"easeofusematplotlib\"\u003eEase of use: matplotlib\u003c/h3\u003e\n\u003cp\u003eFor basic things mpl had the least lines of code and was most intuitive off the bat. Plotly would follow as it has more tools included.\u003c/p\u003e\n\u003ch3 id=\"interactivitybokeh\"\u003eInteractivity: bokeh\u003c/h3\u003e\n\u003cp\u003eBoth are nice, if a little slow sometimes. This was worse in jupyter than on this site. I slightly prefer the lack of hover info by default in bokeh, and also click to drag just feels more natural as the default setting. Not much in it though. Apparently it is possible to get interactive plots inside jupyter with matplotlib, but I've found it a hassle to setup and slightly unreliable.\u003c/p\u003e\n\u003ch3 id=\"aestheticsplotly\"\u003eAesthetics: plotly\u003c/h3\u003e\n\u003cp\u003eLovely looking plots as default. Personal preference, but a clear winner for me.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eFor client-facing tasks, I'll use plotly in the future. For generating quick plots to examine data for my own sake, I'll stick with matplotlib as it's much faster, both in terms of time to render and in terms of using the API. I sometimes use matplotlib with seaborn to make it prettier to show people internally if I'm feeling fancy.\u003c/p\u003e\n\u003cp\u003eIt's a little rough, but you can see the Jupyter Notebook I based this on \u003ca href=\"https://github.com/dgmp88/dgmp88.github.io/tree/master/notebooks/Plotting.ipynb\"\u003ehere\u003c/a\u003e.\u003c/p\u003e"},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"python-plotting"},"buildId":"KH68ggqkYmcXHfjfz910M","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>