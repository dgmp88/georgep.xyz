<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><meta property="og:title" content="Python Plotting Libraries"/><meta property="og:site_name" content="George Prichard&#x27;s blog"/><meta property="og:description"/><meta property="og:image"/><meta name="next-head-count" content="6"/><link rel="preload" href="/_next/static/css/7bf527c5fc874cac.css" as="style"/><link rel="stylesheet" href="/_next/static/css/7bf527c5fc874cac.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-7c9e8fd8226b6573.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c91b8fdce06a16b2.js" defer=""></script><script src="/_next/static/chunks/977-d02d6b0b927a7604.js" defer=""></script><script src="/_next/static/chunks/pages/blog/python-plotting-78fb71b0f0c1f361.js" defer=""></script><script src="/_next/static/14kdXi6XxYeqRBmgVw6i9/_buildManifest.js" defer=""></script><script src="/_next/static/14kdXi6XxYeqRBmgVw6i9/_ssgManifest.js" defer=""></script><script src="/_next/static/14kdXi6XxYeqRBmgVw6i9/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="navbar"><div class="flex-1"><a class="btn btn-ghost normal-case text-xl" href="/">George Prichard</a></div><div class="flex-none"><ul class="menu menu-horizontal p-0"><li><a href="/blog">Blog</a></li></ul></div></div><div class="prose lg:prose-lg mx-auto px-4 py-8"><p>TLDR: Use matplotlib for speed if you&#x27;re just doing a quick analysis for yourself. If you&#x27;re sharing the plots, plotly is definitely worth checking out.</p><p>I&#x27;ve used <a href="https://matplotlib.org/" parentName="p">matplotlib</a> for a while and it&#x27;s awesome - simple API, lots of plotting options. The defaults can be a little ugly, but <a href="https://seaborn.pydata.org/" parentName="p">seaborn</a> can very easily make them all much nicer. However, the graphs generated are pngs/svgs, so don&#x27;t scale that easily and miss out on some cool interactive features of other libraries.</p><p><a href="https://bokeh.pydata.org/en/latest/" parentName="p">Bokeh</a> and <a href="https://plot.ly/" parentName="p">Plotly</a> are two good alternatives. Both are open source, though plotly has a for profit branch linked to Dash, a framework for building analytical webapps. You don&#x27;t need to use it, but default/examples on their docs often do.</p><p>Here I want to compare the 3 on ease of use, functionality and aesthetics.</p><h2>Installation</h2><p>Plotly and Matplotlib are very easy with pip or conda (<inlineCode parentName="p">conda install plotly/matplotlib</inlineCode>). Bokeh also works via pip or seaborn, but if you want it to work with JupyterLab, you&#x27;ll need an extension: <inlineCode parentName="p">jupyter labextension install jupyterlab_bokeh</inlineCode>.</p><h2>Basic examples: Line Plot</h2><p>These are deliberately very bare bones and are just examples of plots I do most frequently. All of the frameworks are super customisable, but if you&#x27;re running a quick analysis you often just want the core features, so I&#x27;m not generally bothering with axis labels and legends.</p><h3>Data</h3><p>Generate some nice offset sine waves and a legend.</p><pre><code class="language-python" parentName="pre">import numpy as np

# Linearly spaced, 0 - 2 * pi
x = np.linspace(0, np.pi*2, 1000)

data = [(&#x27;offset %1.2f&#x27; % i, np.sin(x+i)) for i in np.linspace(0, np.pi, 10)]
legend, ys = zip(*data)
</code></pre><h3>Matplotlib</h3><pre><code class="language-python" parentName="pre">%matplotlib inline
# The first line above needs to be called once to make outputs appear inline in jupyter

import matplotlib.pyplot as plt

# I lied: this is a litte formatting to make the default size comparable to the others.
plt.figure(figsize=(10, 7))


for y in ys:
    plt.plot(x, y)
_ = plt.legend(legend)
</code></pre><p><img src="/images/plotting/matplotlib_line.png" alt="Matplotlib" parentName="p"/></p><h3>Plotly</h3><p>A little bit more boilerplate. We need to generate a bunch of &#x27;traces&#x27;, which are basically just dictionaries, and then hand them to the plotting function.</p><pre><code class="language-python" parentName="pre">import plotly.graph_objs as go
import plotly.offline as py

traces = []

for leg, y in zip(legend, ys):
    traces.append(go.Scatter(x=x, y=y, name=leg))

py.iplot(traces)
</code></pre><iframe width="100%" height="500px" src="/iframes/plotly_line.html" frameborder="0"></iframe><h3>Bokeh</h3><p>Note that we have to set <inlineCode parentName="p">output_notebook</inlineCode> to plot inside the notebook. The alternative is <inlineCode parentName="p">output_file(&#x27;filename.html&#x27;)</inlineCode>.</p><pre><code class="language-python" parentName="pre">from bokeh.plotting import figure, output_notebook, show

output_notebook()

p = figure()

for leg, y in zip(legend, ys):
    p.line(x, y, legend=leg)

show(p)
</code></pre><iframe width="100%" height="650px" src="/iframes/bokeh_line.html" frameborder="0"></iframe><h3>Interim conclusion</h3><p>I love the conciseness of the matplotlib API, the others feel clunky to me in comparsion. But maybe that&#x27;s just what I&#x27;m used to. The interactivity and aesthetics of the others are definitely better though.</p><h2>Basic examples: histogram</h2><p>I made scatter plots, they work similarly to the line plots and aren&#x27;t that interesting to show. Perhaps a more interesting example is something more complex that I also use quite a lot - a histogram of the data to get an idea of its distribution.</p><p>The data, random and normally distributed.</p><pre><code class="language-python" parentName="pre">x = np.random.normal(size=10000)
</code></pre><h3>Matplotlib</h3><p>It doesn&#x27;t get much more concise than this.</p><pre><code class="language-python" parentName="pre">plt.hist(x)
</code></pre><p><img src="/images/plotting/matplotlib_hist.png" alt="Matplotlib" parentName="p"/></p><h3>Plotly</h3><p>Also pretty terse.</p><pre><code class="language-python" parentName="pre">traces = [go.Histogram(x=x)]

py.plot(traces)
</code></pre><iframe width="100%" height="500px" src="/iframes/plotly_hist.html" frameborder="0"></iframe><h3>Bokeh</h3><p>By far the most complex as this isn&#x27;t built in, so we&#x27;re basically just making a bar plot (not sure why this is called &#x27;quad&#x27; here). This is adapted from their docs <a href="https://bokeh.pydata.org/en/latest/docs/gallery/histogram.html" parentName="p">here</a>.</p><pre><code class="language-python" parentName="pre"># Get the bins for the histogram
hist, edges = np.histogram(x, density=True, bins=100)
xx = np.linspace(-2, 2, 1000)

p = figure()
p.quad(top=hist, bottom=0, left=edges[:-1], right=edges[1:])
show(p)
</code></pre><iframe width="100%" height="650px" src="/iframes/bokeh_hist.html" frameborder="0"></iframe><h2>Misc</h2><ul><li parentName="ul">Something kept crashing my jupyter notebook page after some time had gone by since plotting. It looks like the culprit was Bokeh, but it was a little hard to reproduce.</li><li parentName="ul">Both Bokeh and Plotly get a fair bit slower if you have loads of data. e.g. measuring time to render with a stopwatch (<inlineCode parentName="li">%timeit</inlineCode> magic wont measure frontend stuff) and changing the line plot to show 100 examples took:<ul parentName="li"><li parentName="ul">2.6s with matplotlib</li><li parentName="ul">9.2s with plotly</li><li parentName="ul">7.8s with bokeh.</li></ul></li></ul><h2>Winners</h2><h3>Ease of use: matplotlib</h3><p>For basic things mpl had the least lines of code and was most intuitive off the bat. Plotly would follow as it has more tools included.</p><h3>Interactivity: bokeh</h3><p>Both are nice, if a little slow sometimes. This was worse in jupyter than on this site. I slightly prefer the lack of hover info by default in bokeh, and also click to drag just feels more natural as the default setting. Not much in it though. Apparently it is possible to get interactive plots inside jupyter with matplotlib, but I&#x27;ve found it a hassle to setup and slightly unreliable.</p><h3>Aesthetics: plotly</h3><p>Lovely looking plots as default. Personal preference, but a clear winner for me.</p><h2>Conclusion</h2><p>For client-facing tasks, I&#x27;ll use plotly in the future. For generating quick plots to examine data for my own sake, I&#x27;ll stick with matplotlib as it&#x27;s much faster, both in terms of time to render and in terms of using the API. I sometimes use matplotlib with seaborn to make it prettier to show people internally if I&#x27;m feeling fancy.</p><p>It&#x27;s a little rough, but you can see the Jupyter Notebook I based this on <a href="https://github.com/dgmp88/dgmp88.github.io/tree/master/notebooks/Plotting.ipynb" parentName="p">here</a>.</p></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/blog/python-plotting","query":{},"buildId":"14kdXi6XxYeqRBmgVw6i9","nextExport":true,"autoExport":true,"isFallback":false,"scriptLoader":[]}</script></body></html>